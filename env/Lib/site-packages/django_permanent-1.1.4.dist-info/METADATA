Metadata-Version: 2.1
Name: django-permanent
Version: 1.1.4
Summary: Yet another approach to provide soft (logical) delete or masking (thrashing) django models instead of deleting them physically from db.
Home-page: https://github.com/meteozond/django-permanent
Author: Alexander Klimenko
Author-email: alex@erix.ru
License: BSD
Keywords: django,delete,undelete,safedelete,remove,restore,softdelete,logicaldelete,trash
Platform: UNKNOWN
Classifier: Framework :: Django
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: System Administrators
Classifier: Operating System :: OS Independent
Classifier: Topic :: Software Development
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Development Status :: 4 - Beta
Classifier: License :: OSI Approved :: BSD License
Requires-Dist: Django (>=1.6.0)

Django Permanent
================

Yet another approach to provide soft (logical) delete or masking (thrashing) django models instead of deleting them physically from db.

.. image:: https://api.travis-ci.org/meteozond/django-permanent.svg?branch=master

Models
================

To create a non-deletable model just inherit it from ``PermanentModel``::

    class MyModel(PermanentModel):
        pass

It automatically changes delete behaviour to hide objects instead of deleting them::

    >>> a = MyModel.objects.create(pk=1)
    >>> b = MyModel.objects.create(pk=2)
    >>> MyModel.objects.count()
    2
    >>> a.delete()
    >>> MyModel.objects.count()
    1

To recover a deleted object just call its ``restore`` method::

    >>> a.restore()
    >>> MyModel.objects.count()
    2

Use the ``force`` kwarg to enforce physical deletion::

    >>> a.delete(force=True) # Will act as the default django delete
    >>> MyModel._base_manager.count()
    0

If you need to restore a deleted object instead of re-creating the same one use the ``restore_on_create`` attribute::

    class MyModel(PermanentModel):
        class Permanent:
          restore_on_create = True

In this case ``QuerySet`` provides check existence of same attribute objects and restores them if they've been deleted, creating new ones if not.

Managers
================

It changes the default model manager to ignore deleted objects, adding a ``deleted_objects`` manager to see them instead::

    >>> MyModel.objects.count()
    2
    >>> a.delete()
    >>> MyModel.objects.count()
    1
    >>> MyModel.deleted_objects.count()
    1
    >>> MyModel.all_objects.count()
    2
    >>> MyModel._base_manager.count()
    2

QuerySet
================

The ``QuerySet.delete`` method will act as the default django delete, with one exception - objects of models subclassing ``PermanentModel`` will be marked as deleted; the rest will be deleted physically::

    >>> MyModel.objects.all().delete()

You can still force django query set physical deletion::

    >>> MyModel.objects.all().delete(force=True)

Using custom querysets
=======================

1. Inherit your query set from ``PermanentQuerySet``::

    class ServerFileQuerySet(PermanentQuerySet)
        pass

2. Wrap ``PermanentQuerySet`` or ``DeletedQuerySet`` in you model manager declaration::

    class MyModel(PermanentModel)
        objects = MultiPassThroughManager(ServerFileQuerySet, NonDeletedQuerySet)
        deleted_objects = MultiPassThroughManager(ServerFileQuerySet, DeletedQuerySet)
        all_objects = MultiPassThroughManager(ServerFileQuerySet, PermanentQuerySet)

Method ``get_restore_or_create``
=================================

1. Check for existence of the object.
2. Restore it if it was deleted.
3. Create a new one, if it was never created.

Field name
================

The default field named is 'removed', but you can override it with the PERMANENT_FIELD variable in settings.py::

    PERMANENT_FIELD = 'deleted'

Requirements
================

- Django 1.7+
- Python 2.7, 3.4+


